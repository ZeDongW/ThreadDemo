一、自定义线程
	自定义线程有两种方法
	1.继承Thread类：
		自定义线程类通过继承Thread类，需要重写Run()方法
		Run()方法里面是线程的任务代码
		建立线程对象，调用start()方法开启线程任务
	2.实现Runnable接口：
		自定义线程类通过实现Runnable接口，需要重写Run()方法
		Run()方法里面是线程的任务代码
		建立线程对象，将Runnable实现类作为形参传入线程对象，调用start()方法开启线程任务
	通常推荐通过实现Runnable接口来自定义线程，在Java中类都是单继承多实现
二、线程安全问题
	线程安全问题条件：
	1.至少有一个被共享的资源
	2.至少有两个线程争夺该资源
	3.共享的代码至少有两行
三、死锁
	当多个线程互相等待对方资源无法继续执行，会产生死锁现象
	对于死锁，没有解决方案，通常只能避免死锁现象的产生
四、同步锁
	1.同步代码块
		同步代码块的对象可以是任意的
		一个线程在同步代码块中sleep了，并不会释放锁对象
		如果不存在线程安全问题，不要使用同步代码块，会降低程序的运行效率
		锁对象必须是多线程共享的一个资源，才能起作用
	2.同步函数
		同步函数是sychronized修饰的一个函数
		如果是一个非静态的同步函数的锁对象是this对象，若果是静态同步函数的锁对象是当前函数所属类的字节码文件（class对象）
		同步函数的锁是固定的，不能由你来指定
	通常推荐使用同步代码块
		同步代码块的锁对象可以任意指定，同步函数的锁对象是固定的，不能任意指定
		同步代码块就可以很方便的控制被需要同步的代码的范围，同步函数的所有代码都被同步
五、线程通讯
	一个线程完成任务时，要通知另外一个线程去完成另外一个任务
	wait（） 等待 一个线程执行的wait（）方法，会进入阻塞状态，会释放锁对象，只能被其他线程的notify（）方法唤醒
	notify（）唤醒    唤醒等待的线程
	notifyAll（） 唤醒所有等待的线程
	注意事项
		1.wait方法与notify方法是属于Object对象的
		2.两者都需要在同步函数或同步代码快中才能使用
		3.两者都必须由锁对象调用
六、后台线程
	后台线程：就是隐藏起来一直在默默运行的线程，直到进程结束。
	 实现：
	      setDaemon(boolean on)
	 特点：
		当所有的非后台线程结束时，程序也就终止了同时还会杀死进程中的所有后台线程，也就是说，只要有非后台线程还在运行，程序就不会终止，执行main方法的主线程就是一个非后台线程。
	必须在启动线程之前（调用start方法之前）调用setDaemon（true）方法，才可以把该线程设置为后台线程。
	一旦main（）执行完毕，那么程序就会终止，JVM也就退出了。
	可以使用isDaemon() 测试该线程是否为后台线程（守护线程）。
七、Join
	Thread的join方法
	当A线程执行到了B线程Join方法时A就会等待，等B线程都执行完A才会执行，Join可以用来临时加入线程执行
	
	
	